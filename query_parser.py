#!/usr/bin/env python3.8
# @generated by pegen from query_parser.g

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser


class Node:
	pass

class And(Node):

	def __init__(self, *children):
		self.children = list(children)

	def __repr__(self):
		buf = "(and "
		sep = ""
		for child in self.children:
			buf += sep + repr(child)
			sep = " "
		buf += ")"
		return buf

	def _complete_fields(self, name):
		for i, child in enumerate(self.children):
			self.children[i] = child._complete_fields(name)
		return self

class Or(Node):

	def __init__(self, *children):
		self.children = list(children)

	def __repr__(self):
		buf = "(or "
		sep = ""
		for child in self.children:
			buf += sep + repr(child)
			sep = " "
		buf += ")"
		return buf

	def _complete_fields(self, name):
		for i, child in enumerate(self.children):
			self.children[i] = child._complete_fields(name)
		return self

class Not(Node):

	def __init__(self, child=None):
		self.child = child

	def __repr__(self):
		buf = "(not "
		buf += repr(self.child)
		buf += ")"
		return buf

	def _complete_fields(self, name):
		self.child = self.child._complete_fields(name)
		return self

class Field(Node):

	def __init__(self, name, child=None):
		self.name = name
		self.child = child

	def __repr__(self):
		return f"{self.name or '<null>'}:{self.child!r}"

	def _complete_fields(self, name):
		if not self.name:
			self.name = name
		if isinstance(self.child, str):
			return self
		return self.child._complete_fields(self.name)

class _Null(Node):

	def __repr__(self):
		return "<null>"

	def _complete_fields(self, name):
		return self

Null = _Null()

def mkbinop(klass, l, r):
	if isinstance(l, klass):
		l.children.append(r)
		return l
	return klass(l, r)

def mkand(*elems):
	return mkbinop(And, *elems)

def mkor(*elems):
	return mkbinop(Or, *elems)

def mkmerge(*elems):
	match len(elems):
		case 0:
			return Null
		case 1:
			return elems[0]
		case 2:
			return mkand(*elems)
		case _:
			return And(*elems)


# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):

    @memoize
    def start(self) -> Optional[Any]:
        # start: Exprs $
        mark = self._mark()
        if (
            (r := self.Exprs())
            and
            (self.expect('ENDMARKER'))
        ):
            return r . _complete_fields ( "_default" );
        self._reset(mark)
        return None;

    @memoize
    def Exprs(self) -> Optional[Any]:
        # Exprs: Expr*
        # nullable=True
        mark = self._mark()
        if (
            (r := self._loop0_1(),)
        ):
            return mkmerge ( * r );
        self._reset(mark)
        return None;

    @memoize
    def Expr(self) -> Optional[Any]:
        # Expr: OrExpr
        mark = self._mark()
        if (
            (OrExpr := self.OrExpr())
        ):
            return OrExpr;
        self._reset(mark)
        return None;

    @memoize
    def FieldExpr(self) -> Optional[Any]:
        # FieldExpr: Text (':' | '=') PrimaryExpr | PrimaryExpr
        mark = self._mark()
        if (
            (name := self.Text())
            and
            (self._tmp_2())
            and
            (r := self.PrimaryExpr())
        ):
            return Field ( name , r );
        self._reset(mark)
        if (
            (PrimaryExpr := self.PrimaryExpr())
        ):
            return PrimaryExpr;
        self._reset(mark)
        return None;

    @memoize
    def PrimaryExpr(self) -> Optional[Any]:
        # PrimaryExpr: '(' Expr ')' | Text
        mark = self._mark()
        if (
            (self.expect('('))
            and
            (r := self.Expr())
            and
            (self.expect(')'))
        ):
            return r;
        self._reset(mark)
        if (
            (r := self.Text())
        ):
            return Field ( None , r );
        self._reset(mark)
        return None;

    @memoize_left_rec
    def OrExpr(self) -> Optional[Any]:
        # OrExpr: OrExpr ("or" | "OR") AndExpr | AndExpr
        mark = self._mark()
        if (
            (r := self.OrExpr())
            and
            (self._tmp_3())
            and
            (s := self.AndExpr())
        ):
            return mkor ( r , s );
        self._reset(mark)
        if (
            (AndExpr := self.AndExpr())
        ):
            return AndExpr;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def AndExpr(self) -> Optional[Any]:
        # AndExpr: AndExpr ("and" | "AND") NotExpr | NotExpr
        mark = self._mark()
        if (
            (r := self.AndExpr())
            and
            (self._tmp_4())
            and
            (s := self.NotExpr())
        ):
            return mkand ( r , s );
        self._reset(mark)
        if (
            (NotExpr := self.NotExpr())
        ):
            return NotExpr;
        self._reset(mark)
        return None;

    @memoize
    def NotExpr(self) -> Optional[Any]:
        # NotExpr: ("not" | "NOT") NotExpr | FieldExpr
        mark = self._mark()
        if (
            (self._tmp_5())
            and
            (r := self.NotExpr())
        ):
            return Not ( r );
        self._reset(mark)
        if (
            (FieldExpr := self.FieldExpr())
        ):
            return FieldExpr;
        self._reset(mark)
        return None;

    @memoize
    def Text(self) -> Optional[Any]:
        # Text: NAME
        mark = self._mark()
        if (
            (r := self.name())
        ):
            return r . string;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_1(self) -> Optional[Any]:
        # _loop0_1: Expr
        mark = self._mark()
        children = []
        while (
            (Expr := self.Expr())
        ):
            children.append(Expr)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_2(self) -> Optional[Any]:
        # _tmp_2: ':' | '='
        mark = self._mark()
        if (
            (literal := self.expect(':'))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect('='))
        ):
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_3(self) -> Optional[Any]:
        # _tmp_3: "or" | "OR"
        mark = self._mark()
        if (
            (literal := self.expect("or"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("OR"))
        ):
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_4(self) -> Optional[Any]:
        # _tmp_4: "and" | "AND"
        mark = self._mark()
        if (
            (literal := self.expect("and"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("AND"))
        ):
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_5(self) -> Optional[Any]:
        # _tmp_5: "not" | "NOT"
        mark = self._mark()
        if (
            (literal := self.expect("not"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("NOT"))
        ):
            return literal;
        self._reset(mark)
        return None;

    KEYWORDS = ()
    SOFT_KEYWORDS = ('AND', 'NOT', 'OR', 'and', 'not', 'or')


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
