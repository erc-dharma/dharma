#!/usr/bin/env python3.8
# @generated by pegen from query_parser.g

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser


class Node:
	pass

class And(Node):

	def __init__(self, *children):
		self.children = list(children)

	def __repr__(self):
		buf = "(and "
		sep = ""
		for child in self.children:
			buf += sep + repr(child)
			sep = " "
		buf += ")"
		return buf

class Or(Node):

	def __init__(self, *children):
		self.children = list(children)

	def __repr__(self):
		buf = "(or "
		sep = ""
		for child in self.children:
			buf += sep + repr(child)
			sep = " "
		buf += ")"
		return buf

class Not(Node):

	def __init__(self, child=None):
		self.child = child

	def __repr__(self):
		buf = "(not "
		buf += repr(self.child)
		buf += ")"
		return buf

class Field(Node):

	def __init__(self, name, child=None):
		self.name = name
		self.child = child

	def __repr__(self):
		return f"{self.name}:{self.child!r}"

class _Null(Node):

	def __repr__(self):
		return "<null>"

Null = _Null()

def mkbinop(klass, l, r):
	if isinstance(l, klass):
		l.children.append(r)
		return l
	elif isinstance(r, klass):
		r.children.append(l)
		return r
	return And(l, r)

def mkand(*elems):
	return mkbinop(And, *elems)

def mkor(*elems):
	return mkbinop(Or, *elems)

def mkmerge(*elems):
	match len(elems):
		case 0:
			return Null
		case 1:
			return elems[0]
		case 2:
			return mkand(*elems)
		case _:
			return And(*elems)


# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):

    @memoize
    def start(self) -> Optional[Any]:
        # start: Exprs $
        mark = self._mark()
        if (
            (r := self.Exprs())
            and
            (self.expect('ENDMARKER'))
        ):
            return r;
        self._reset(mark)
        return None;

    @memoize
    def Exprs(self) -> Optional[Any]:
        # Exprs: FieldExpr+
        mark = self._mark()
        if (
            (r := self._loop1_1())
        ):
            return mkmerge ( * r );
        self._reset(mark)
        return None;

    @memoize
    def FieldExpr(self) -> Optional[Any]:
        # FieldExpr: Text ':' BoolExpr | BoolExpr
        mark = self._mark()
        if (
            (name := self.Text())
            and
            (self.expect(':'))
            and
            (r := self.BoolExpr())
        ):
            return Field ( name , r );
        self._reset(mark)
        if (
            (BoolExpr := self.BoolExpr())
        ):
            return BoolExpr;
        self._reset(mark)
        return None;

    @memoize
    def BoolExpr(self) -> Optional[Any]:
        # BoolExpr: '(' OrExpr ')' | OrExpr
        mark = self._mark()
        if (
            (self.expect('('))
            and
            (r := self.OrExpr())
            and
            (self.expect(')'))
        ):
            return r;
        self._reset(mark)
        if (
            (OrExpr := self.OrExpr())
        ):
            return OrExpr;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def OrExpr(self) -> Optional[Any]:
        # OrExpr: OrExpr "or" AndExpr | AndExpr
        mark = self._mark()
        if (
            (r := self.OrExpr())
            and
            (self.expect("or"))
            and
            (s := self.AndExpr())
        ):
            return mkor ( r , s );
        self._reset(mark)
        if (
            (AndExpr := self.AndExpr())
        ):
            return AndExpr;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def AndExpr(self) -> Optional[Any]:
        # AndExpr: AndExpr "and" NotExpr | NotExpr
        mark = self._mark()
        if (
            (r := self.AndExpr())
            and
            (self.expect("and"))
            and
            (s := self.NotExpr())
        ):
            return mkand ( r , s );
        self._reset(mark)
        if (
            (NotExpr := self.NotExpr())
        ):
            return NotExpr;
        self._reset(mark)
        return None;

    @memoize
    def NotExpr(self) -> Optional[Any]:
        # NotExpr: "not" NotExpr | Text
        mark = self._mark()
        if (
            (self.expect("not"))
            and
            (r := self.NotExpr())
        ):
            return Not ( r );
        self._reset(mark)
        if (
            (Text := self.Text())
        ):
            return Text;
        self._reset(mark)
        return None;

    @memoize
    def Text(self) -> Optional[Any]:
        # Text: STRING | NAME
        mark = self._mark()
        if (
            (r := self.string())
        ):
            return r . string;
        self._reset(mark)
        if (
            (r := self.name())
        ):
            return r . string;
        self._reset(mark)
        return None;

    @memoize
    def _loop1_1(self) -> Optional[Any]:
        # _loop1_1: FieldExpr
        mark = self._mark()
        children = []
        while (
            (FieldExpr := self.FieldExpr())
        ):
            children.append(FieldExpr)
            mark = self._mark()
        self._reset(mark)
        return children;

    KEYWORDS = ()
    SOFT_KEYWORDS = ('and', 'not', 'or')


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
